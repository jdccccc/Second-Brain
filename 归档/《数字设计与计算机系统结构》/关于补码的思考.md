---
title: 关于补码的思考
categories:
  - Theory
  - 数制
  - 补码
tags:
  - 补码

---

## <!--关于补码的思考-->

考虑时钟模型：

对于0～12有双重含义，当时钟顺时针转7个单位时相当于逆时针转5个单位，也就是顺时针转-5个单位。

定义运算mod:
$$
a\in N^*,m \in N^*\\
a\in[0,m)时，a\ mod\ m= a\\
a\in (-m,0),a\ mod \ m=m+a\\
a\in [m,+\infin),a\ mod \ m=m-a\%m*m\\
a\in [-\infin, -m],a\ mod \ m=m+a+(-a)\%m*m
$$
该运算具有如下性质：
$$
b>0,(a+b)mod \ m= (a-(m-b))mod \ m\\
b<0,(a+b)mod \ m=(a+(m+b))mod\ m
$$
时钟模型解释以上定义：

- 时钟顺时针转17个单位等效于顺时针转5个单位
- 时钟逆时针转17个单位等效于顺时针转（12+（-17）+（17%12）×12）=7个单位

- 顺时针转n个单位和逆时针转12-n个单位具有等效性

故而在该运算定义下中在进行加法运算时可以有以下等式：
$$
b\in (-\infin,0),b=m+b
$$
时钟模型举例:

- -3 = 9
- -5 = 7

现在定义补码：

定义8位补码:
$$
m = 256_{10}=100000000_{2}\\
对于N\in[0,127]_{10},N_{补码}=N\\
对于N\in[-128,-1]_{10},N_{补码}=256+N
$$
解释：

- 当$N=-60$时，$N_{补码}=196$

- 可以看出在上述定义的mod256运算当中，N和N补码是互相等效的

- mod256+运算中每一个正数b代表本身和-(256-b)两重含义，但是编码不能具有两重含义

- 故而进一步的

  - 规定$N_{补码}\in[0,127]$代表$N_{补码}=N,N\ge0$
  - 规定$N_{补码}\in[128,255]$代表$N_{补码}=256+N,N<0$

- 这中定义的指定使得补码的加法运算的结果

  - 落在[0,127]之间，仅表示时钟顺时针转
  - 落在[127,255]之间，仅表示时钟逆时针转

- 这样做的目的是为了使得

  - 首位满足符号位要求
  - 编码的唯一性
  - 二进制加减法的实现

- 但是这种指定会产生溢出现象，因为本身正负等效的两部分被分别指派了正负性，这使得失效部分的定义成为了溢出。

  - 如果两个补码正数相加，补码结果b落在了[128,255]之间，如果是原先的定义则表示时钟顺时针转了[128,255]或者[-128,-1]，但是现在按照补码的只能表示顺时针转了[-128,-1]，两个正数的结果是一个负数，显然不符合二进制加法的规则，此时产生正溢出
  - 如果两个补码负数相加，结果落在了[0,127]之间，同理，产生了负数相加得到正数的结果，不符合实数加法的规则，此时产生负溢出。本来[0,127]等效于[-256,-129],但是此时只能表示[0,127]

- 之所以引进补码，主要是为了利用mod+运算中的正负等效性将加减法映射为补码后统一由加法解决，补码正数+负数不会产生溢出，（<!--关于补码的思考-->

  考虑时钟模型：

  对于0～12有双重含义，当时钟顺时针转7个单位时相当于逆时针转5个单位，也就是顺时针转-5个单位。

  定义运算mod:
  $$
  a\in N^*,m \in N^*\\
  a\in[0,m)时，a\ mod\ m= a\\
  a\in (-m,0),a\ mod \ m=m+a\\
  a\in [m,+\infin),a\ mod \ m=m-a\%m*m\\
  a\in [-\infin, -m],a\ mod \ m=m+a+(-a)\%m*m
  $$
  该运算具有如下性质：
  $$
  b>0,(a+b)mod \ m= (a-(m-b))mod \ m\\
  b<0,(a+b)mod \ m=(a+(m+b))mod\ m
  $$
  时钟模型解释以上定义：

  - 时钟顺时针转17个单位等效于顺时针转5个单位
  - 时钟逆时针转17个单位等效于顺时针转（12+（-17）+（17%12）×12）=7个单位

  - 顺时针转n个单位和逆时针转12-n个单位具有等效性

  故而在该运算定义下中在进行加法运算时可以有以下等式：
  $$
  b\in (-\infin,0),b=m+b
  $$
  时钟模型举例:

  - -3 = 9
  - -5 = 7

  现在定义补码：

  定义8位补码:
  $$
  m = 256_{10}=100000000_{2}\\
  对于N\in[0,127]_{10},N_{补码}=N\\
  对于N\in[-128,-1]_{10},N_{补码}=256+N
  $$
  解释：

  - 当$N=-60$时，$N_{补码}=196$
  - 可以看出在上述定义的mod256运算当中，N和N补码是互相等效的
  - mod256+运算中每一个正数b代表本身和-(256-b)两重含义，但是编码不能具有两重含义
  - 故而进一步的
    - 规定$N_{补码}\in[0,127]$代表$N_{补码}=N,N\ge0$
    - 规定$N_{补码}\in[128,255]$代表$N_{补码}=256+N,N<0$
  - 这中定义的指定使得补码的加法运算的结果
    - 落在[0,127]之间，仅表示时钟顺时针转
    - 落在[127,255]之间，仅表示时钟逆时针转
  - 这样做的目的是为了使得
    - 首位满足符号位要求
    - 编码的唯一性
    - 二进制加减法的实现
  - 但是这种指定会产生溢出现象，因为本身正负等效的两部分被分别指派了正负性，这使得失效部分的定义成为了溢出。
    - 如果两个补码正数相加，补码结果b落在了[128,255]之间，如果是原先的定义则表示时钟顺时针转了[128,255]或者[-128,-1]，但是现在按照补码的只能表示顺时针转了[-128,-1]，两个正数的结果是一个负数，显然不符合二进制加法的规则，此时产生正溢出
    - 如果两个补码负数相加，结果落在了[0,127]之间，同理，产生了负数相加得到正数的结果，不符合实数加法的规则，此时产生负溢出。本来[0,127]等效于[-256,-129],但是此时只能表示[0,127]
  - 之所以引进补码，主要是为了利用mod+运算中的正负等效性将加减法映射为补码后统一由加法解决，补码正数+负数不会产生溢出，（省略进位本身相当于mod运算）。

- 省略进位本身相当于mod运算）。
